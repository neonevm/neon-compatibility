{
  "uid" : "3fb0bf4a4336787a",
  "name" : "test_brownie_deploy",
  "fullName" : "tests.brownie.test_brownie#test_brownie_deploy",
  "historyId" : "6e83a925951bfd8b9c39b6ea82974dc9",
  "time" : {
    "start" : 1639695084901,
    "stop" : 1639695084901,
    "duration" : 0
  },
  "status" : "broken",
  "statusMessage" : "requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionResetError(104, 'Connection reset by peer')\", ConnectionResetError(104, 'Connection reset by peer'))",
  "statusTrace" : "self = <urllib3.response.HTTPResponse object at 0x7fd87eaf05e0>\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n>               yield\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/urllib3/response.py:438: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.response.HTTPResponse object at 0x7fd87eaf05e0>, amt = 1024\ndecode_content = True, cache_content = False\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`http.client.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n    \n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n    \n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n    \n        if self._fp is None:\n            return\n    \n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n>               data = self._fp.read(amt) if not fp_closed else b\"\"\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/urllib3/response.py:519: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPResponse object at 0x7fd87eaf0a00>, amt = 1024\n\n    def read(self, amt=None):\n        if self.fp is None:\n            return b\"\"\n    \n        if self._method == \"HEAD\":\n            self._close_conn()\n            return b\"\"\n    \n        if amt is not None:\n            # Amount is given, implement using readinto\n            b = bytearray(amt)\n>           n = self.readinto(b)\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/http/client.py:459: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPResponse object at 0x7fd87eaf0a00>\nb = bytearray(b'f\\x0fo\\xa4$\\xa0\\x02\\x00\\x00\\x0f\\x11\\xa4$\\xf8\\x02\\x00\\x00\\xe9l\\xfb\\xff\\xfff.\\x0f\\x1f\\x84\\x00\\x00\\x00\\x00\\x0...0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into bytearray b and return the number\n        of bytes read.\n        \"\"\"\n    \n        if self.fp is None:\n            return 0\n    \n        if self._method == \"HEAD\":\n            self._close_conn()\n            return 0\n    \n        if self.chunked:\n            return self._readinto_chunked(b)\n    \n        if self.length is not None:\n            if len(b) > self.length:\n                # clip the read to the \"end of response\"\n                b = memoryview(b)[0:self.length]\n    \n        # we do not use _safe_read() here because this may be a .will_close\n        # connection, and the user is reading more bytes than will be provided\n        # (for example, reading in 1k chunks)\n>       n = self.fp.readinto(b)\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/http/client.py:503: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <socket.SocketIO object at 0x7fd87eaf0f40>\nb = <memory at 0x7fd87eadbc40>\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into the writable buffer *b* and return\n        the number of bytes read.  If the socket is non-blocking and no bytes\n        are available, None is returned.\n    \n        If *b* is non-empty, a 0 return value indicates that the connection\n        was shutdown at the other end.\n        \"\"\"\n        self._checkClosed()\n        self._checkReadable()\n        if self._timeout_occurred:\n            raise OSError(\"cannot read from timed out object\")\n        while True:\n            try:\n>               return self._sock.recv_into(b)\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/socket.py:669: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nbuffer = <memory at 0x7fd87eadbc40>, nbytes = 8192, flags = 0\n\n    def recv_into(self, buffer, nbytes=None, flags=0):\n        self._checkClosed()\n        if buffer and (nbytes is None):\n            nbytes = len(buffer)\n        elif nbytes is None:\n            nbytes = 1024\n        if self._sslobj is not None:\n            if flags != 0:\n                raise ValueError(\n                  \"non-zero flags not allowed in calls to recv_into() on %s\" %\n                  self.__class__)\n>           return self.read(nbytes, buffer)\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/ssl.py:1241: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nlen = 8192, buffer = <memory at 0x7fd87eadbc40>\n\n    def read(self, len=1024, buffer=None):\n        \"\"\"Read up to LEN bytes and return them.\n        Return zero-length string on EOF.\"\"\"\n    \n        self._checkClosed()\n        if self._sslobj is None:\n            raise ValueError(\"Read on closed or unwrapped SSL socket.\")\n        try:\n            if buffer is not None:\n>               return self._sslobj.read(len, buffer)\nE               ConnectionResetError: [Errno 104] Connection reset by peer\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/ssl.py:1099: ConnectionResetError\n\nDuring handling of the above exception, another exception occurred:\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, 'stream'):\n            try:\n>               for chunk in self.raw.stream(chunk_size, decode_content=True):\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/requests/models.py:758: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.response.HTTPResponse object at 0x7fd87eaf05e0>, amt = 1024\ndecode_content = True\n\n    def stream(self, amt=2 ** 16, decode_content=None):\n        \"\"\"\n        A generator wrapper for the read() method. A call will block until\n        ``amt`` bytes have been read from the connection or until the\n        connection is closed.\n    \n        :param amt:\n            How much of the content to read. The generator will return up to\n            much data per iteration, but may return less. This is particularly\n            likely when using compressed data. However, the empty string will\n            never be returned.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        if self.chunked and self.supports_chunked_reads():\n            for line in self.read_chunked(amt, decode_content=decode_content):\n                yield line\n        else:\n            while not is_fp_closed(self._fp):\n>               data = self.read(amt=amt, decode_content=decode_content)\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/urllib3/response.py:576: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.response.HTTPResponse object at 0x7fd87eaf05e0>, amt = 1024\ndecode_content = True, cache_content = False\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`http.client.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n    \n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n    \n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n    \n        if self._fp is None:\n            return\n    \n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n                data = self._fp.read(amt) if not fp_closed else b\"\"\n                if (\n                    amt != 0 and not data\n                ):  # Platform-specific: Buggy versions of Python.\n                    # Close the connection when no data is returned\n                    #\n                    # This is redundant to what httplib/http.client _should_\n                    # already do.  However, versions of python released before\n                    # December 15, 2012 (http://bugs.python.org/issue16298) do\n                    # not properly close the connection in all cases. There is\n                    # no harm in redundantly calling close.\n                    self._fp.close()\n                    flush_decoder = True\n                    if self.enforce_content_length and self.length_remaining not in (\n                        0,\n                        None,\n                    ):\n                        # This is an edge case that httplib failed to cover due\n                        # to concerns of backward compatibility. We're\n                        # addressing it here to make sure IncompleteRead is\n                        # raised during streaming, so all calls with incorrect\n                        # Content-Length are caught.\n>                       raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/urllib3/response.py:541: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <contextlib._GeneratorContextManager object at 0x7fd87eaca730>\ntype = <class 'ConnectionResetError'>\nvalue = ConnectionResetError(104, 'Connection reset by peer')\ntraceback = <traceback object at 0x7fd87e757900>\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = type()\n            try:\n>               self.gen.throw(type, value, traceback)\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/contextlib.py:131: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.response.HTTPResponse object at 0x7fd87eaf05e0>\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n                yield\n    \n            except SocketTimeout:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n    \n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):\n                    # SSL errors related to framing/MAC get wrapped and reraised here\n                    raise SSLError(e)\n    \n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n    \n            except (HTTPException, SocketError) as e:\n                # This includes IncompleteRead.\n>               raise ProtocolError(\"Connection broken: %r\" % e, e)\nE               urllib3.exceptions.ProtocolError: (\"Connection broken: ConnectionResetError(104, 'Connection reset by peer')\", ConnectionResetError(104, 'Connection reset by peer'))\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/urllib3/response.py:455: ProtocolError\n\nDuring handling of the above exception, another exception occurred:\n\n    @pytest.fixture(scope=\"session\")\n    def brownie_project():\n        accounts.add()\n>       pr = project.load(\n            str((pathlib.Path(__file__).parent / 'token').absolute())\n        )\n\ntests/brownie/conftest.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py:750: in load\n    return Project(name, project_path)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py:182: in __init__\n    self.load()\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py:237: in load\n    self._compile(changed, self._compiler_config, False)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py:94: in _compile\n    build_json = compiler.compile_and_format(\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/compiler/__init__.py:105: in compile_and_format\n    find_solc_versions(solc_sources, install_needed=True, silent=silent)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/compiler/solidity.py:173: in find_solc_versions\n    install_solc(*to_install)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/compiler/solidity.py:105: in install_solc\n    solcx.install_solc(version, show_progress=True)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/solcx/install.py:452: in install_solc\n    _install_solc_unix(version, filename, show_progress, solcx_binary_path)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/solcx/install.py:603: in _install_solc_unix\n    content = _download_solc(download, show_progress)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/solcx/install.py:589: in _download_solc\n    for data in response.iter_content(1024, decode_unicode=True):\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/requests/utils.py:536: in stream_decode_response_unicode\n    for item in iterator:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, 'stream'):\n            try:\n                for chunk in self.raw.stream(chunk_size, decode_content=True):\n                    yield chunk\n            except ProtocolError as e:\n>               raise ChunkedEncodingError(e)\nE               requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionResetError(104, 'Connection reset by peer')\", ConnectionResetError(104, 'Connection reset by peer'))\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/requests/models.py:761: ChunkedEncodingError",
  "flaky" : false,
  "newFailed" : false,
  "newBroken" : true,
  "newPassed" : false,
  "retriesCount" : 0,
  "retriesStatusChange" : false,
  "beforeStages" : [ {
    "name" : "configure_neon_network",
    "time" : {
      "start" : 1639695083310,
      "stop" : 1639695083310,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "brownie_project",
    "time" : {
      "start" : 1639695084901,
      "stop" : 1639695088769,
      "duration" : 3868
    },
    "status" : "broken",
    "statusMessage" : "requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionResetError(104, 'Connection reset by peer')\", ConnectionResetError(104, 'Connection reset by peer'))\n",
    "statusTrace" : "  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/pluggy/_callers.py\", line 39, in _multicall\n    res = hook_impl.function(*args)\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/_pytest/fixtures.py\", line 1126, in pytest_fixture_setup\n    result = call_fixture_func(fixturefunc, request, kwargs)\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/_pytest/fixtures.py\", line 932, in call_fixture_func\n    fixture_result = fixturefunc(**kwargs)\n  File \"/home/runner/work/neon-compatibility/neon-compatibility/tests/brownie/conftest.py\", line 33, in brownie_project\n    pr = project.load(\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py\", line 750, in load\n    return Project(name, project_path)\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py\", line 182, in __init__\n    self.load()\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py\", line 237, in load\n    self._compile(changed, self._compiler_config, False)\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py\", line 94, in _compile\n    build_json = compiler.compile_and_format(\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/compiler/__init__.py\", line 105, in compile_and_format\n    find_solc_versions(solc_sources, install_needed=True, silent=silent)\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/compiler/solidity.py\", line 173, in find_solc_versions\n    install_solc(*to_install)\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/compiler/solidity.py\", line 105, in install_solc\n    solcx.install_solc(version, show_progress=True)\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/solcx/install.py\", line 452, in install_solc\n    _install_solc_unix(version, filename, show_progress, solcx_binary_path)\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/solcx/install.py\", line 603, in _install_solc_unix\n    content = _download_solc(download, show_progress)\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/solcx/install.py\", line 589, in _download_solc\n    for data in response.iter_content(1024, decode_unicode=True):\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/requests/utils.py\", line 536, in stream_decode_response_unicode\n    for item in iterator:\n  File \"/home/runner/.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/requests/models.py\", line 761, in generate\n    raise ChunkedEncodingError(e)\n",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : true,
    "hasContent" : true
  } ],
  "testStage" : {
    "status" : "broken",
    "statusMessage" : "requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionResetError(104, 'Connection reset by peer')\", ConnectionResetError(104, 'Connection reset by peer'))",
    "statusTrace" : "self = <urllib3.response.HTTPResponse object at 0x7fd87eaf05e0>\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n>               yield\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/urllib3/response.py:438: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.response.HTTPResponse object at 0x7fd87eaf05e0>, amt = 1024\ndecode_content = True, cache_content = False\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`http.client.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n    \n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n    \n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n    \n        if self._fp is None:\n            return\n    \n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n>               data = self._fp.read(amt) if not fp_closed else b\"\"\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/urllib3/response.py:519: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPResponse object at 0x7fd87eaf0a00>, amt = 1024\n\n    def read(self, amt=None):\n        if self.fp is None:\n            return b\"\"\n    \n        if self._method == \"HEAD\":\n            self._close_conn()\n            return b\"\"\n    \n        if amt is not None:\n            # Amount is given, implement using readinto\n            b = bytearray(amt)\n>           n = self.readinto(b)\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/http/client.py:459: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPResponse object at 0x7fd87eaf0a00>\nb = bytearray(b'f\\x0fo\\xa4$\\xa0\\x02\\x00\\x00\\x0f\\x11\\xa4$\\xf8\\x02\\x00\\x00\\xe9l\\xfb\\xff\\xfff.\\x0f\\x1f\\x84\\x00\\x00\\x00\\x00\\x0...0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00')\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into bytearray b and return the number\n        of bytes read.\n        \"\"\"\n    \n        if self.fp is None:\n            return 0\n    \n        if self._method == \"HEAD\":\n            self._close_conn()\n            return 0\n    \n        if self.chunked:\n            return self._readinto_chunked(b)\n    \n        if self.length is not None:\n            if len(b) > self.length:\n                # clip the read to the \"end of response\"\n                b = memoryview(b)[0:self.length]\n    \n        # we do not use _safe_read() here because this may be a .will_close\n        # connection, and the user is reading more bytes than will be provided\n        # (for example, reading in 1k chunks)\n>       n = self.fp.readinto(b)\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/http/client.py:503: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <socket.SocketIO object at 0x7fd87eaf0f40>\nb = <memory at 0x7fd87eadbc40>\n\n    def readinto(self, b):\n        \"\"\"Read up to len(b) bytes into the writable buffer *b* and return\n        the number of bytes read.  If the socket is non-blocking and no bytes\n        are available, None is returned.\n    \n        If *b* is non-empty, a 0 return value indicates that the connection\n        was shutdown at the other end.\n        \"\"\"\n        self._checkClosed()\n        self._checkReadable()\n        if self._timeout_occurred:\n            raise OSError(\"cannot read from timed out object\")\n        while True:\n            try:\n>               return self._sock.recv_into(b)\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/socket.py:669: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nbuffer = <memory at 0x7fd87eadbc40>, nbytes = 8192, flags = 0\n\n    def recv_into(self, buffer, nbytes=None, flags=0):\n        self._checkClosed()\n        if buffer and (nbytes is None):\n            nbytes = len(buffer)\n        elif nbytes is None:\n            nbytes = 1024\n        if self._sslobj is not None:\n            if flags != 0:\n                raise ValueError(\n                  \"non-zero flags not allowed in calls to recv_into() on %s\" %\n                  self.__class__)\n>           return self.read(nbytes, buffer)\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/ssl.py:1241: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ssl.SSLSocket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\nlen = 8192, buffer = <memory at 0x7fd87eadbc40>\n\n    def read(self, len=1024, buffer=None):\n        \"\"\"Read up to LEN bytes and return them.\n        Return zero-length string on EOF.\"\"\"\n    \n        self._checkClosed()\n        if self._sslobj is None:\n            raise ValueError(\"Read on closed or unwrapped SSL socket.\")\n        try:\n            if buffer is not None:\n>               return self._sslobj.read(len, buffer)\nE               ConnectionResetError: [Errno 104] Connection reset by peer\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/ssl.py:1099: ConnectionResetError\n\nDuring handling of the above exception, another exception occurred:\n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, 'stream'):\n            try:\n>               for chunk in self.raw.stream(chunk_size, decode_content=True):\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/requests/models.py:758: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.response.HTTPResponse object at 0x7fd87eaf05e0>, amt = 1024\ndecode_content = True\n\n    def stream(self, amt=2 ** 16, decode_content=None):\n        \"\"\"\n        A generator wrapper for the read() method. A call will block until\n        ``amt`` bytes have been read from the connection or until the\n        connection is closed.\n    \n        :param amt:\n            How much of the content to read. The generator will return up to\n            much data per iteration, but may return less. This is particularly\n            likely when using compressed data. However, the empty string will\n            never be returned.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        if self.chunked and self.supports_chunked_reads():\n            for line in self.read_chunked(amt, decode_content=decode_content):\n                yield line\n        else:\n            while not is_fp_closed(self._fp):\n>               data = self.read(amt=amt, decode_content=decode_content)\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/urllib3/response.py:576: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.response.HTTPResponse object at 0x7fd87eaf05e0>, amt = 1024\ndecode_content = True, cache_content = False\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`http.client.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n    \n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n    \n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n    \n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n    \n        if self._fp is None:\n            return\n    \n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n    \n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n                data = self._fp.read(amt) if not fp_closed else b\"\"\n                if (\n                    amt != 0 and not data\n                ):  # Platform-specific: Buggy versions of Python.\n                    # Close the connection when no data is returned\n                    #\n                    # This is redundant to what httplib/http.client _should_\n                    # already do.  However, versions of python released before\n                    # December 15, 2012 (http://bugs.python.org/issue16298) do\n                    # not properly close the connection in all cases. There is\n                    # no harm in redundantly calling close.\n                    self._fp.close()\n                    flush_decoder = True\n                    if self.enforce_content_length and self.length_remaining not in (\n                        0,\n                        None,\n                    ):\n                        # This is an edge case that httplib failed to cover due\n                        # to concerns of backward compatibility. We're\n                        # addressing it here to make sure IncompleteRead is\n                        # raised during streaming, so all calls with incorrect\n                        # Content-Length are caught.\n>                       raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/urllib3/response.py:541: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <contextlib._GeneratorContextManager object at 0x7fd87eaca730>\ntype = <class 'ConnectionResetError'>\nvalue = ConnectionResetError(104, 'Connection reset by peer')\ntraceback = <traceback object at 0x7fd87e757900>\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = type()\n            try:\n>               self.gen.throw(type, value, traceback)\n\n/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/contextlib.py:131: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib3.response.HTTPResponse object at 0x7fd87eaf05e0>\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n    \n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n    \n        try:\n            try:\n                yield\n    \n            except SocketTimeout:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n    \n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):\n                    # SSL errors related to framing/MAC get wrapped and reraised here\n                    raise SSLError(e)\n    \n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n    \n            except (HTTPException, SocketError) as e:\n                # This includes IncompleteRead.\n>               raise ProtocolError(\"Connection broken: %r\" % e, e)\nE               urllib3.exceptions.ProtocolError: (\"Connection broken: ConnectionResetError(104, 'Connection reset by peer')\", ConnectionResetError(104, 'Connection reset by peer'))\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/urllib3/response.py:455: ProtocolError\n\nDuring handling of the above exception, another exception occurred:\n\n    @pytest.fixture(scope=\"session\")\n    def brownie_project():\n        accounts.add()\n>       pr = project.load(\n            str((pathlib.Path(__file__).parent / 'token').absolute())\n        )\n\ntests/brownie/conftest.py:33: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py:750: in load\n    return Project(name, project_path)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py:182: in __init__\n    self.load()\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py:237: in load\n    self._compile(changed, self._compiler_config, False)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/main.py:94: in _compile\n    build_json = compiler.compile_and_format(\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/compiler/__init__.py:105: in compile_and_format\n    find_solc_versions(solc_sources, install_needed=True, silent=silent)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/compiler/solidity.py:173: in find_solc_versions\n    install_solc(*to_install)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/brownie/project/compiler/solidity.py:105: in install_solc\n    solcx.install_solc(version, show_progress=True)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/solcx/install.py:452: in install_solc\n    _install_solc_unix(version, filename, show_progress, solcx_binary_path)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/solcx/install.py:603: in _install_solc_unix\n    content = _download_solc(download, show_progress)\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/solcx/install.py:589: in _download_solc\n    for data in response.iter_content(1024, decode_unicode=True):\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/requests/utils.py:536: in stream_decode_response_unicode\n    for item in iterator:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    def generate():\n        # Special case for urllib3.\n        if hasattr(self.raw, 'stream'):\n            try:\n                for chunk in self.raw.stream(chunk_size, decode_content=True):\n                    yield chunk\n            except ProtocolError as e:\n>               raise ChunkedEncodingError(e)\nE               requests.exceptions.ChunkedEncodingError: (\"Connection broken: ConnectionResetError(104, 'Connection reset by peer')\", ConnectionResetError(104, 'Connection reset by peer'))\n\n../../../.local/share/virtualenvs/neon-compatibility-g882AfFF/lib/python3.8/site-packages/requests/models.py:761: ChunkedEncodingError",
    "steps" : [ ],
    "attachments" : [ {
      "uid" : "8b8485ee464a95ef",
      "name" : "log",
      "source" : "8b8485ee464a95ef.txt",
      "type" : "text/plain",
      "size" : 129
    }, {
      "uid" : "bbaa20734a5dd74e",
      "name" : "stdout",
      "source" : "bbaa20734a5dd74e.txt",
      "type" : "text/plain",
      "size" : 104
    }, {
      "uid" : "3b067645b808e2cd",
      "name" : "stderr",
      "source" : "3b067645b808e2cd.txt",
      "type" : "text/plain",
      "size" : 568
    } ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 3,
    "shouldDisplayMessage" : true,
    "hasContent" : true
  },
  "afterStages" : [ ],
  "labels" : [ {
    "name" : "feature",
    "value" : "Brownie"
  }, {
    "name" : "parentSuite",
    "value" : "tests.brownie"
  }, {
    "name" : "suite",
    "value" : "test_brownie"
  }, {
    "name" : "host",
    "value" : "fv-az135-242"
  }, {
    "name" : "thread",
    "value" : "4448-MainThread"
  }, {
    "name" : "framework",
    "value" : "pytest"
  }, {
    "name" : "language",
    "value" : "cpython3"
  }, {
    "name" : "package",
    "value" : "tests.brownie.test_brownie"
  }, {
    "name" : "resultFormat",
    "value" : "allure2"
  } ],
  "parameters" : [ ],
  "links" : [ ],
  "hidden" : false,
  "retry" : false,
  "extra" : {
    "severity" : "normal",
    "retries" : [ ],
    "categories" : [ {
      "name" : "Test defects",
      "matchedStatuses" : [ ],
      "flaky" : false
    } ],
    "history" : {
      "statistic" : {
        "failed" : 0,
        "broken" : 18,
        "skipped" : 0,
        "passed" : 88,
        "unknown" : 0,
        "total" : 106
      },
      "items" : [ {
        "uid" : "b9bbf280857da753",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/247//#testresult/b9bbf280857da753",
        "status" : "passed",
        "time" : {
          "start" : 1639684776180,
          "stop" : 1639684781104,
          "duration" : 4924
        }
      }, {
        "uid" : "28f615ec57ca0915",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/245//#testresult/28f615ec57ca0915",
        "status" : "passed",
        "time" : {
          "start" : 1639674131236,
          "stop" : 1639674137303,
          "duration" : 6067
        }
      }, {
        "uid" : "f25f772720e52d2a",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/242//#testresult/f25f772720e52d2a",
        "status" : "broken",
        "statusDetails" : "ValueError: Gas estimation failed: 'Transaction simulation failed: Insufficient funds for fee'. This transaction will likely revert. If you wish to broadcast, you must set the gas limit manually.",
        "time" : {
          "start" : 1639663138781,
          "stop" : 1639663139178,
          "duration" : 397
        }
      }, {
        "uid" : "a3f99ea0dc70111",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/241//#testresult/a3f99ea0dc70111",
        "status" : "passed",
        "time" : {
          "start" : 1639661267834,
          "stop" : 1639661273094,
          "duration" : 5260
        }
      }, {
        "uid" : "4df132bf53c3e832",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/238//#testresult/4df132bf53c3e832",
        "status" : "passed",
        "time" : {
          "start" : 1639651767866,
          "stop" : 1639651774781,
          "duration" : 6915
        }
      }, {
        "uid" : "523e836a676280d5",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/237//#testresult/523e836a676280d5",
        "status" : "passed",
        "time" : {
          "start" : 1639648220192,
          "stop" : 1639648226797,
          "duration" : 6605
        }
      }, {
        "uid" : "650d7558ef084ae",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/236//#testresult/650d7558ef084ae",
        "status" : "passed",
        "time" : {
          "start" : 1639645563924,
          "stop" : 1639645570607,
          "duration" : 6683
        }
      }, {
        "uid" : "863cedb857420976",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/235//#testresult/863cedb857420976",
        "status" : "passed",
        "time" : {
          "start" : 1639643135951,
          "stop" : 1639643143494,
          "duration" : 7543
        }
      }, {
        "uid" : "7b1c597b041c9303",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/234//#testresult/7b1c597b041c9303",
        "status" : "passed",
        "time" : {
          "start" : 1639632903559,
          "stop" : 1639632907530,
          "duration" : 3971
        }
      }, {
        "uid" : "5956b2e9b6bf25a8",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/233//#testresult/5956b2e9b6bf25a8",
        "status" : "passed",
        "time" : {
          "start" : 1639624437120,
          "stop" : 1639624444048,
          "duration" : 6928
        }
      }, {
        "uid" : "6ada061d466dd073",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/232//#testresult/6ada061d466dd073",
        "status" : "passed",
        "time" : {
          "start" : 1639614645351,
          "stop" : 1639614650313,
          "duration" : 4962
        }
      }, {
        "uid" : "b793c7cfe11a7f98",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/230//#testresult/b793c7cfe11a7f98",
        "status" : "passed",
        "time" : {
          "start" : 1639590924983,
          "stop" : 1639590930114,
          "duration" : 5131
        }
      }, {
        "uid" : "e2aac51676ad0a",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/228//#testresult/e2aac51676ad0a",
        "status" : "passed",
        "time" : {
          "start" : 1639580715266,
          "stop" : 1639580719223,
          "duration" : 3957
        }
      }, {
        "uid" : "bb93bd51d8339bca",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/227//#testresult/bb93bd51d8339bca",
        "status" : "passed",
        "time" : {
          "start" : 1639577757154,
          "stop" : 1639577764980,
          "duration" : 7826
        }
      }, {
        "uid" : "f470e2a312f82e28",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/226//#testresult/f470e2a312f82e28",
        "status" : "passed",
        "time" : {
          "start" : 1639575068310,
          "stop" : 1639575072801,
          "duration" : 4491
        }
      }, {
        "uid" : "6debfee98a272d36",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/225//#testresult/6debfee98a272d36",
        "status" : "passed",
        "time" : {
          "start" : 1639574762764,
          "stop" : 1639574766115,
          "duration" : 3351
        }
      }, {
        "uid" : "6940309ce5cac9d1",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/224//#testresult/6940309ce5cac9d1",
        "status" : "passed",
        "time" : {
          "start" : 1639574139490,
          "stop" : 1639574143932,
          "duration" : 4442
        }
      }, {
        "uid" : "2fed1d3b19d06272",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/223//#testresult/2fed1d3b19d06272",
        "status" : "passed",
        "time" : {
          "start" : 1639573328594,
          "stop" : 1639573332480,
          "duration" : 3886
        }
      }, {
        "uid" : "6ae4cee35f53c058",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/222//#testresult/6ae4cee35f53c058",
        "status" : "passed",
        "time" : {
          "start" : 1639537989952,
          "stop" : 1639537994046,
          "duration" : 4094
        }
      }, {
        "uid" : "496e570a912fc8aa",
        "reportUrl" : "https://neonlabsorg.github.io/neon-compatibility/221//#testresult/496e570a912fc8aa",
        "status" : "passed",
        "time" : {
          "start" : 1639528313374,
          "stop" : 1639528316935,
          "duration" : 3561
        }
      } ]
    },
    "tags" : [ ]
  },
  "source" : "3fb0bf4a4336787a.json",
  "parameterValues" : [ ]
}